# First Assignment of the Research Track 2 course (Robotics Engineering / JEMARO, Unige) Ermanno Girardo S4506472

# Requirements of ros2 branch
Localisation and path planning of a non-holonomic robot in an environment with Gazebo simulator.
The package contains the nodes and the simulation environment for controlling a mobile robot in the Gazebo simulation environment.
The aim of this branch is to run the Gazebo simulation by launching the two nodes in C++ in ROS2 by the ros1_bridge package.
Then the two C++ nodes must be written in a composable format in order to be managed as a components.

# What you can find in this branch 
In this branch you can find two nodes in python and two nodes in C++:

* go_to_point.py is a server used to reach the position of a random target.
  In this script is implemented the behaviour of an Finite State Machine in order to:
  1) align the robot with the goal
  2) move the robot in the direction of the goal
  3) once the goal is reached the robot align its orientation with the goal's orientation
  This node uses a publisher in order to publish the velocity of the robot  
  on /cmd_vel topic and it uses a subscriber in order to check the robot's position on /odom topic.

* user_interface.py implements an user interface in order to start or stop the robot.
  In particular it is a client that reads the user command and via custom service message Command.srv 
  send it to the state_machine node.
  When the user press 1 the node sends a "start" messagge to the user_interface server.
  Instead if the user press 0 the node the function of go_to_point is stopped and in state_machine node 
  the goal is cancelled, setting also the velocity to zero.
  
* position_service.cpp is a simple server that has the scope of generate a random target.
  This node infact generate three random components (x and y components for the position,
  theta component for the orientation) in a specified interval [min,max] via 
  custom service message RandomPosition.srv.
  The node is written in C++ composable format in order to be a component node
  
* state_machine.cpp is a node wich communicats with all other nodes, in particular:
  1) a client is generated in order to set the fields of the random target and send the request
     to position_service
  2) The node implements a function callback of the user_interface , in order to check the request done
     by the user, setting properly the value of the variable start.
  3) Another client is implemented in order to send a request to server /go_to_point in order to reach
     the random goal generated by the service /position_service.
     The node is written in C++ composable format in order to be a component node.

* src folder for the two nodes in C++
* srv folder with the custom service messages
* cmake_list
* package.xml
* urdf folder for the Universal Robot Description      
* launch file my_launch.py used to launch the 2 nodes as component and also the container.
* docs folder with the doxygen documentation
* my_mapping_rules.yaml
    
# How to set the ros1_bridge package
  
1) download the ros1_bridge from the GitHub repository into your ros2 workspace
  ```
  git clone https://github.com/ros2/ros1_bridge
  ```
2) to swith the ROS version faster i suggest to create three executables files into your root folder
  In order to do this move into root folder then:
    ```
    gedit ros.sh
    #!/bin/bash
    source /root/my_ros/devel/setup.bash
    ```
  To make this file an executable:
   ```
   chmod +x ros.sh
   ```
  This file must be launched whenever you want to source your noetic version of ROS.
  
  Then to create the executable for sourcing your foxy version
  
    ```
    gedit ros2.sh
    #!/bin/bash
    source /opt/ros/foxy/setup.bash
    source /root/my_ros2/install/local_setup.bash
    ```
 This file must be launched whenever you want to source your noetic version of ROS.
 Always change the permission of the file.
 
 Then you must be create the third executable to source both noetic and foxy version of ROS
  
    ```
    gedit ros12.sh
    #!/bin/bash
    source /root/my_ros/devel/setup.bash
    source /opt/ros/foxy/setup.bash
    source /root/my_ros2/install/local_setup.bash
    ```
3) In order to bridge the three custom service messages exits the my_mapping_rules.yaml
     Also the Cmake_list and the package.xml have been modified.
     
4) Only now we can build the ros1_bridge into our ros2 workspace.
     In order to do this source the ros12.sh and moove into your ros2 workspace and run the following command
     
     ```
     colcon build --packages-select ros1_bridge --cmake-force-configure
     ```
     
  5) Once the ros1_bridge is successfully built you can check if the messagges are correctly bridged
     Run the following command:
     
     ```
     ros2 run ros1_bridge dynamic_bridge --print-pairs
     ```
   you should see the following lines on your terminal:
    rt2_assignment1/srv/Command' (ROS 2) <=> 'rt2_assignment1/Command' (ROS 1)
    rt2_assignment1/srv/Position' (ROS 2) <=> 'rt2_assignment1/Position' (ROS 1)
    rt2_assignment1/srv/RandomPosition' (ROS 2) <=> 'rt2_assignment1/RandomPosition' (ROS 1)
    Then the ros1_bridge is correctly built.
    
# Launch file 

You can find a launch folder with inside a launch file.
This launch file is need to launch simultaneosly the container and the two components in C++

# How to launch the simulation

1) Open the first terminal and run the following commands in order to source noetic version and lauch the .launch file
   Remember that in ROS2 distribution the launch file is written in python.
   ```
   cd
   source ros.sh
   cd my_ros/
   roslaunch rt2_assignment1 simBridge.launch
   ```
   In this way the two scripts in python should run and Gazebo simulator should starts.
   
2) Open a second terminal and run the following commands in order to source both noetic and foxy and launch the bridge
   ```
   cd
   source ros12.sh
   cd my_ros2/
   ros2 run ros1_bridge dynamic_bridge
   ```
   In this way the messages should be bridged
   
3) Open a third terminal and run the following commands in order to source foxy and launch the launch file.
   Remember that in ROS2 distribution the launch file must be written in python
   ```
   cd
   source ros2.sh
   cd my_ros2/
   ros2 launch my_launch.py
   ```
   In this way the container and the two nodes should run.
   To check if it works digit the following command after have sourced foxy
   
  ```
  ros2 component list
  ```
  After this three passages the simulation should works
  
# Launch all in one single command

  Install gnome-terminal running the following command:
  ```
  install gnome-terminal
  ```
  Put the script gnomeGazebo.sh into the path where you put the prevoius three executable
  then change the permission to gnomeGazebo.sh
  ```
  chmod +x  gnomeGazebo.sh
  ```
  In order to launch the script digit
  ```
  ./gnomeGazebo.sh
  ```

     
     
     
     

